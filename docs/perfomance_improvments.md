# Оптимизации производительности

## Предусловия

Прежде чем улучшать производительность приложения, изначально было необходимо её оценить, после чего определить наиболее ресурсно-затратные участки.

С изначальным уровнем производительности приложения можно ознакомиться в документе [по подключению асинхронного драйвера баз данных](./async_driver_perfomance.md). TL;DR: адекватные тайминги до 280 RPS и полная деградация работы приложения при 360 RPS.

На той же версии приложения и на той же виртуальной машине был проведён профайлинг с помощью py-spy. Генерировалась линейно увеличивающаяся нагрузка на сервер со 100 RPS до 200 RPS в течение 2 минут. Результаты профилирования сохранены в [файле](./speedscope/2025-05-02_15-25-13_control.prof). Ниже скрин визуализации

![Визуализация контрольного профиля приложения под тестовой нагрузкой](./images/2025-05-02_15-48-50_profile_from_100rps_to_200rps_for_2m.png)

Из интересного - непосредственно код ручки занимает ~8% всего времени (на графике функция `get_ingredients`). Но вообще почему-то есть отдельно нарисованный блок с запросами sqlmodel/sqlalchemy ~16%. И даже если объединить их, то бизнес логика занимает не больше 25% всего времени.

Наиболее очевидным место для оптимизации выглядят логи - можно получить до 20%.

Также можно заметить, что ~8% занимает разрешение зависимостей, половина из которых - синхронные функции, запускаемые в threadpool. Возможно, если сделать их асинхронными, то время их работы сильно сократится.
